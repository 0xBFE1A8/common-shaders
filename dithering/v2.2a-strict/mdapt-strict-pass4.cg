/* COMPATIBILITY 
   - HLSL compilers
   - Cg   compilers
*/

/*
   Merge Dithering and Pseudo Transparency Shader v2.2a [STRICT EDITION] - Pass 4
   by Sp00kyFox, 2013

   Blends tagged pixels with tagged neighbors.

*/

#define round(X) floor((X)+0.5)
#define TEX(dx,dy) tex2D(decal, VAR.texCoord+float2((dx),(dy))*VAR.t1)


float getw(float4 color)
{
	return round(2. * color.w);
}

bool eq(float4 A, float4 B)
{
	return A.x == B.x && A.y == B.y && A.z == B.z;
}

float3 mergeVL(float4 C, float4 L, float4 R)
{
	bool bL = L.w == 1;
	bool bR = R.w == 1;

	return C / (1 + 1*(bL || bR)) + (bL * L + bR * R) / (2 + 2*(bL && bR));
}

float3 mergeCB(float4 C, float4 UL, float4 UR, float4 DL, float4 DR, float4 U1, float4 D1, float4 L1, float4 R1)
{
	//standard formula: C/4 + (UL + UR + DR + DL)/16 + (L1 + R1 + D1 + U1)/8

	bool bUL = UL.w == 2 || eq(UL,C) || (D1.w == 2 && eq(UL,D1)) || (R1.w == 2 && eq(UL,R1));
	bool bUR = UR.w == 2 || eq(UR,C) || (D1.w == 2 && eq(UR,D1)) || (L1.w == 2 && eq(UR,L1));
	bool bDL = DL.w == 2 || eq(DL,C) || (U1.w == 2 && eq(DL,U1)) || (R1.w == 2 && eq(DL,R1));
	bool bDR = DR.w == 2 || eq(DR,C) || (U1.w == 2 && eq(DR,U1)) || (L1.w == 2 && eq(DR,L1));

	bool bU1 = U1.w == 2 || eq(U1,C) || (D1.w == 2 && eq(U1,D1));
	bool bD1 = D1.w == 2 || eq(D1,C) || (U1.w == 2 && eq(D1,U1));
	bool bL1 = L1.w == 2 || eq(L1,C) || (R1.w == 2 && eq(L1,R1));
	bool bR1 = R1.w == 2 || eq(R1,C) || (L1.w == 2 && eq(R1,L1));

	float3 B = bUL * UL + bUR * UR + bDL * DL + bDR * DR;
	float3 W = bU1 * U1 + bD1 * D1 + bL1 * L1 + bR1 * R1;
	
	float cntB = bUL + bUR + bDL + bDR;
	float cntW = bU1 + bD1 + bL1 + bR1;	

	bool bB = cntB != 0;
	bool bW = cntW != 0;

	return C / (2 * bB + 2 * bW + (!bB && !bW)) + B / (cntB * (2 + 2 * bW) + !bB) + W / (cntW * 2 + !bW);	
}


struct input
{
      float2 video_size;
      float2 texture_size;
      float2 output_size;
};

struct out_vertex {
        float4 position : POSITION;
        float2 texCoord : TEXCOORD0;
        float2 t1;
};


/*    VERTEX_SHADER    */
out_vertex main_vertex
(
	float4 position	: POSITION,
	float2 texCoord : TEXCOORD0,

   	uniform float4x4 modelViewProj,
	uniform input IN
)
{
        out_vertex OUT;

        OUT.position = mul(modelViewProj, position);

        float2 ps = float2(1.0/IN.texture_size.x, 1.0/IN.texture_size.y);
        float dx  = ps.x;
        float dy  = ps.y;

        OUT.texCoord = texCoord;
        OUT.t1       = float2(dx, dy); // F H

        return OUT;
}

/*    FRAGMENT SHADER    */
float3 main_fragment(in out_vertex VAR, uniform sampler2D decal : TEXUNIT0, uniform input IN) : COLOR
{
	/*
		UL U1 UR
		L1 C  R1
		DL D1 DR	
	*/


	float4 C  = TEX( 0, 0);		C.w  = getw(C);
	float4 L1 = TEX(-1, 0);		L1.w = getw(L1);
	float4 R1 = TEX( 1, 0);		R1.w = getw(R1);
	float4 U1 = TEX( 0,-1);		U1.w = getw(U1);
	float4 D1 = TEX( 0, 1);		D1.w = getw(D1);
	float4 UL = TEX(-1,-1);		UL.w = getw(UL);
	float4 UR = TEX( 1,-1);		UR.w = getw(UR);
	float4 DL = TEX(-1, 1);		DL.w = getw(DL);
	float4 DR = TEX( 1, 1);		DR.w = getw(DR);


	/*
	tag values:
		0	nothing	

		1	vertical lines

		2	checkerboard
		3	checkerboard strict
	*/


	bool VL = C.w == 1;
	bool CB = !VL && C.w == 2;

	// smoothing vertical lines
	VL = VL || (!CB && ((L1.w == 1 && R1.w == 1) || (U1.w == 1 && D1.w == 1 && dot(C - L1, C - R1) > 0)));
	
	// smoothing checkerboard
	CB = CB || (!VL && ((L1.w == 2 && eq(C,L1)) || (R1.w == 2 && eq(C,R1)) || (U1.w == 2 && eq(C,U1)) || (D1.w == 2 && eq(C,D1)) || (UL.w == 2 && eq(C,UL)) || (UR.w == 2 && eq(C,UR)) || (DL.w == 2 && eq(C,DL)) || (DR.w == 2 && eq(C,DR))));

	return C * (!CB && !VL) + VL * mergeVL(C,L1,R1) + CB * mergeCB(C,UL,UR,DL,DR,U1,D1,L1,R1);
}
