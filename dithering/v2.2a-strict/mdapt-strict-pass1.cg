/* COMPATIBILITY 
   - HLSL compilers
   - Cg   compilers
*/

/*
   Merge Dithering and Pseudo Transparency Shader v2.2a [STRICT EDITION] - Pass 1
   by Sp00kyFox, 2013

   Finds specific patterns and tags their central pixel.

*/

#define round(X) floor((X)+0.5)
#define TEX(dx,dy) tex2D(decal, VAR.texCoord+float2((dx),(dy))*VAR.t1)


// Set comment to deactivate detection of checkerboard (CB) and vertical line (VL) patterns.
#define CB
//#define VL


/*
output tag values:
	0	nothing	
	
	1	vertical lines 2x1

	2	checkerboard 2x2
*/

const static float outVL  = 1./2.;
const static float outCB  = 1;


bool eq(float3 A, float3 B)
{
	return A.x == B.x && A.y == B.y && A.z == B.z;
}


struct input
{
	float2 video_size;
	float2 texture_size;
	float2 output_size;
};

struct out_vertex {
        float4 position : POSITION;
        float2 texCoord : TEXCOORD0;
        float2 t1;
};


/*    VERTEX_SHADER    */
out_vertex main_vertex
(
	float4 position	: POSITION,
	float2 texCoord : TEXCOORD0,

   	uniform float4x4 modelViewProj,
	uniform input IN
)
{
        out_vertex OUT;

        OUT.position = mul(modelViewProj, position);

        float2 ps = float2(1.0/IN.texture_size.x, 1.0/IN.texture_size.y);
        float dx  = ps.x;
        float dy  = ps.y;

        OUT.texCoord = texCoord;
        OUT.t1       = float2(dx, dy); // F H

        return OUT;
}

/*    FRAGMENT SHADER    */
float4 main_fragment(in out_vertex VAR, uniform sampler2D decal : TEXUNIT0, uniform input IN) : COLOR
{
	/*
		            UUL U2 UUR
		        ULL UL  U1 UR  URR
		        L2  L1  C  R1  R2
		        DLL DL  D1 DR  DRR	
			    DDL D2 DDR
	*/


	float3 C   = TEX( 0, 0);
	float3 R1  = TEX( 1, 0);
	float3 U1  = TEX( 0,-1);
	float3 UR  = TEX( 1,-1);
	float3 L1  = TEX(-1, 0);
	float3 D1  = TEX( 0, 1);
	float3 R2  = TEX( 2, 0);
	float3 DR  = TEX( 1, 1);


	/*
	dot product tags

		0	nothing
		1	horizontal
		2	vertical
		3	horizontal & vertical
	*/

	float c, r1;

	float3 CdR1  = C  - R1;
	float3 CdU1  = C  - U1;
	float3 R1dUR = R1 - UR;

	c   = (dot(C - L1, CdR1) > 0) ? 1 : 0;
	c  += (dot(C - D1, CdU1) > 0) ? 2 : 0;

	r1  = (dot(R1 - R2, -CdR1) > 0) ? 1 : 0;
	r1 += (dot(R1 - DR, R1dUR) > 0) ? 2 : 0;


	bool bVL  = false;
	bool bCB  = false;

#ifdef VL

	bVL = c==1 && r1==1 && (eq(L1,R1) || eq(C,R2));

#endif

#ifdef CB

	float3 UL  = TEX(-1,-1);
	float3 U2  = TEX( 0,-2);
	float3 URR = TEX( 2,-1);
	float3 UUR = TEX( 1,-2);

	float u1, ur;

	float3 U1dUR = U1 - UR;

	u1  = (dot(U1 - UL, U1dUR) > 0) ? 1 : 0;
	u1 += (dot(U1 - U2, -CdU1) > 0) ? 2 : 0;

	ur  = (dot(UR - URR, -U1dUR) > 0) ? 1 : 0;
	ur += (dot(UR - UUR, -R1dUR) > 0) ? 2 : 0; 

	bool bED = (u1 == 0 && r1 == 0) || (c == 0 && ur == 0); // Edge Detection

	bCB = !bVL && !eq(C,R1) && eq(C,UR) && eq(R1,U1) && !bED;

#endif


	return float4(C, bVL * outVL + bCB * outCB);
}
