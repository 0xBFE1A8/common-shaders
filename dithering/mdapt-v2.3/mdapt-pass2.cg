/* COMPATIBILITY 
   - HLSL compilers
   - Cg   compilers
*/

/*
   Merge Dithering and Pseudo Transparency Shader v2.3 - Pass 2
   by Sp00kyFox, 2013

   Terminates isolated detections.

*/

#define TEX(dx,dy) tex2D(decal, VAR.texCoord+float2((dx),(dy))*VAR.t1).xy


// Minimum number of tagged connected pixels in 5x5 area (Vertical Lines, Checkerboard).
const static int2 thresh = int2(5,8);		// valid range: ([0,10], [0,24])


struct input
{
	float2 video_size;
	float2 texture_size;
	float2 output_size;
};

struct out_vertex {
        float4 position : POSITION;
        float2 texCoord : TEXCOORD0;
        float2 t1;
};


/*    VERTEX_SHADER    */
out_vertex main_vertex
(
	float4 position	: POSITION,
	float2 texCoord : TEXCOORD0,

   	uniform float4x4 modelViewProj,
	uniform input IN
)
{
        out_vertex OUT;

        OUT.position = mul(modelViewProj, position);

        float2 ps = float2(1.0/IN.texture_size.x, 1.0/IN.texture_size.y);
        float dx  = ps.x;
        float dy  = ps.y;

        OUT.texCoord = texCoord;
        OUT.t1       = float2(dx, dy); // F H

        return OUT;
}

/*    FRAGMENT SHADER    */
float2 main_fragment(in out_vertex VAR, uniform sampler2D decal : TEXUNIT0, uniform input IN) : COLOR
{

	/*
		        NW  UUL U2 UUR NE
		        ULL UL  U1 UR  URR
		        L2  L1  C  R1  R2
		        DLL DL  D1 DR  DRR	
			SW  DDL D2 DDR SE
	*/

	float2 C = TEX( 0, 0);

	int2 hits = int2(0,0);
	

	//phase 1
	bool2 L1 = TEX(-1, 0) && C;
	bool2 R1 = TEX( 1, 0) && C;
	bool2 U1 = TEX( 0,-1) && C;
	bool2 D1 = TEX( 0, 1) && C;

	//phase 2
	bool2 L2 = TEX(-2, 0) && L1;
	bool2 R2 = TEX( 2, 0) && R1;
	bool2 U2 = TEX( 0,-2) && U1;
	bool2 D2 = TEX( 0, 2) && D1;
	bool2 UL = TEX(-1,-1) && (L1 || U1);
	bool2 UR = TEX( 1,-1) && (R1 || U1);
	bool2 DL = TEX(-1, 1) && (L1 || D1);
	bool2 DR = TEX( 1, 1) && (R1 || D1);

	//phase 3
	bool2 ULL = TEX(-2,-1) && (L2 || UL);
	bool2 URR = TEX( 2,-1) && (R2 || UR);
	bool2 DRR = TEX( 2, 1) && (R2 || DR);
	bool2 DLL = TEX(-2, 1) && (L2 || DL);
	bool2 UUL = TEX(-1,-2) && (U2 || UL);
	bool2 UUR = TEX( 1,-2) && (U2 || UR);
	bool2 DDR = TEX( 1, 2) && (D2 || DR);
	bool2 DDL = TEX(-1, 2) && (D2 || DL);

	//phase 4
	hits += TEX(-2,-2) && (UUL || ULL);
	hits += TEX( 2,-2) && (UUR || URR);
	hits += TEX(-2, 2) && (DDL || DLL);
	hits += TEX( 2, 2) && (DDR || DRR);


	hits += (ULL + URR + DRR + DLL + L2 + R2) + int2(0,1) * (U1 + U2 + D1 + D2 + L1 + R1 + UL + UR + DL + DR + UUL + UUR + DDR + DDL);


	return C * (hits >= thresh);
}
