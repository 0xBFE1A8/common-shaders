/* COMPATIBILITY 
   - HLSL compilers
   - Cg   compilers
*/

/*
   Merge Dithering and Pseudo Transparency Shader v2.4 - Pass 1
   by Sp00kyFox, 2013

   Preparing patterns and marking them.

*/

#define TEX(dx,dy)   tex2D(IN.texture,   texCoord+float2((dx),(dy))*t1)
#define TEXt0(dx,dy) tex2D(ORIG.texture, texCoord+float2((dx),(dy))*t1).xyz

const static float sq3 = sqrt(3.);

float eq(float3 A, float3 B){
	return (sq3 - length(A-B))/sq3;
}

float and(float a, float b, float c){
	return min(a, min(b,c));
}

float and(float a, float b, float c, float d, float e){
	return min(a, min(b, min(c, min(d,e))));
}

float or(float a, float b){
	return max(a,b);
}

float or(float a, float b, float c){
	return max(a, max(b,c));
}

float or(float a, float b, float c, float d, float e){
	return max(a, max(b, max(c, max(d,e))));
}

struct previous
{
	uniform sampler2D texture;
	float2 tex_coord;
};

struct input
{
	float2 video_size;
	float2 texture_size;
	float2 output_size;
	sampler2D texture : TEXUNIT0;
};

struct tex_coords
{
	float2 tex;
	float2 or;
};

/*    VERTEX_SHADER    */
void main_vertex
(
	float2 tex : TEXCOORD,	
	float4 position : POSITION,
	uniform float4x4 modelViewProj,

	previous ORIG,

	out float4 oPosition : POSITION,
	out tex_coords coords
)
{
	oPosition = mul(modelViewProj, position);

	coords = tex_coords(tex, ORIG.tex_coord);
}

/*    FRAGMENT SHADER    */
float2 main_fragment(in float2 texCoord : TEXCOORD0, uniform input IN, previous ORIG) : COLOR
{

        float2 t1 = float2(1.0/IN.texture_size.x, 1.0/IN.texture_size.y);

	/*
		UL  U  UR
		L   C  R
		DL  D  DR
	*/


	float4 C = TEX( 0, 0);
	float4 L = TEX(-1, 0);
	float4 R = TEX( 1, 0);
	float4 D = TEX( 0, 1);
	float4 U = TEX( 0,-1);
	
	float UL = TEX(-1,-1).z;
	float UR = TEX( 1,-1).z;
	float DL = TEX(-1, 1).z;
	float DR = TEX( 1, 1).z;

	float3 c = TEXt0( 0, 0);
	float3 l = TEXt0(-1, 0);
	float3 r = TEXt0( 1, 0);
	float3 d = TEXt0( 0, 1);
	float3 u = TEXt0( 0,-1);
	
	// Vertical Lines
	float fVL = and(C.x, L.x, R.x);

	// Checkerboard
	float eqLxU = eq(l,u), eqRxU = eq(r,u), eqLxD = eq(l,d), eqRxD = eq(r,d), eqLxR = eq(l,r), eqUxD = eq(u,d);
	
	float fCB = or(C.z,
			and(C.x, L.z, R.z, eqLxR, or(and(U.x, eqLxU, eqRxU), and(D.x, eqLxD, eqRxD))),
			and(C.y, U.z, D.z, eqUxD, or(and(L.y, eqLxU, eqLxD), and(R.y, eqRxU, eqRxD))),
			and(C.x, L.x, R.x, eqLxR, or(and(UL, U.z, UR, eqLxU, eqRxU), and(DL, D.z, DR, eqLxD, eqRxD))),
			and(C.y, U.y, D.y, eqUxD, or(and(UL, L.z, DL, eqLxU, eqLxD), and(UR, R.z, DR, eqRxU, eqRxD))));

	return float2(fVL, fCB);
}
