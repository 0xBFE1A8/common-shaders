struct data
{
   float2 tex;
   float pix_no;
   float one;
};

struct input
{
   float2 video_size;
   float2 texture_size;
   float2 output_size;
};

void main_vertex
(
   float4 position : POSITION,
   out float4 oPosition : POSITION,
   uniform float4x4 modelViewProj,
   float2 tex : TEXCOORD,
   uniform input IN,
   out data oData
)
{
   oPosition = mul(modelViewProj, position);
   oData.tex = tex;
   oData.tex.y -= 0.5 / IN.texture_size.y;
   oData.pix_no = tex.y * IN.texture_size.y;
   oData.one = 1.0 / IN.texture_size.y;
}

float3 beam(float3 color, float dist)
{
   const float width = 0.25;
   float3 x = dist / width;
   return color * exp(-0.5 * x * x) / width;
}

#define BOOST 0.85

#define HORIZ_GAUSS_WIDTH 0.5

float4 main_fragment (uniform input IN, in data vertex, uniform sampler2D s0 : TEXUNIT0) : COLOR
{
#define TEX(off_y) tex2D(s0, vertex.tex + float2(0.0, off_y * vertex.one)).rgb

   float3 top = TEX(0);
   float3 bottom = TEX(1);

   float offset_dist = frac(vertex.pix_no - 0.5);
   float dist0 = offset_dist;
   float dist1 = dist0 - 1.0;

   float3 scanline = float3(0.0);

   scanline += beam(top, dist0);
   scanline += beam(bottom, dist1);

   return float4(BOOST * scanline / 1.15, 1.0);
}

